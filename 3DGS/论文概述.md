### 3DGS（3D Gaussian Splatting）

原文链接：[3D Gaussian Splatting for Real-Time Radiance Field Rendering](https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/3d_gaussian_splatting_high.pdf)

3D高斯溅射（3D Gaussian Splatting）是一项革命性的**三维场景重建与实时渲染**技术。它以其**惊人的渲染速度**、卓越的视觉质量和相对快速的训练时间，迅速席卷了计算机图形学界，被认为是继神经辐射场（NeRF）之后的又一重大突破。

这项技术的核心思想是，不再使用传统的多边形网格或NeRF所依赖的神经网络来表示三维场景，而是采用数以百万计的微小、半透明的椭球体——即“**3D高斯体**（3D Gaussians）”——来共同“描绘”出整个场景。每一个高斯体都拥有独立的位置、形状（大小和方向）、颜色和透明度等属性。

<img width="1415" height="296" alt="image" src="https://github.com/user-attachments/assets/95ba1c64-809d-445c-ac7d-b53d75982737" />


#### 1. 3D高斯体的数学表达

场景由N个3D高斯体构成。每个高斯体的核心是一个位于三维空间中心点 <img src="https://latex.codecogs.com/svg.latex?\mu" alt="\mu" /> 的高斯分布。其对空间中任意一点 <img src="https://latex.codecogs.com/svg.latex?x" alt="x" /> 的影响由以下高斯函数定义：

<p align="center">
<img src="https://latex.codecogs.com/svg.latex?G(x)%20%3D%20e%5E%7B-%5Cfrac%7B1%7D%7B2%7D(x-%5Cmu)%5ET%20%5CSigma%5E%7B-1%7D%20(x-%5Cmu)%7D" alt="G(x) = e^{-\frac{1}{2}(x-\mu)^T \Sigma^{-1} (x-\mu)}" />
</p>

这里的关键参数是：

* <img src="https://latex.codecogs.com/svg.latex?x" alt="x" />: 空间中的任意一点。
* <img src="https://latex.codecogs.com/svg.latex?\mu" alt="\mu" />: 高斯体的中心位置（Position），是一个三维向量 <img src="https://latex.codecogs.com/svg.latex?(x%2C%20y%2C%20z)" alt="(x, y, z)" />。这是需要优化的参数之一。
* <img src="https://latex.codecogs.com/svg.latex?\Sigma" alt="\Sigma" />: **协方差矩阵（Covariance Matrix）**，是一个 <img src="https://latex.codecogs.com/svg.latex?3%20%5Ctimes%203" alt="3 \times 3" /> 的半正定矩阵。这个矩阵是理解高斯体形状的关键，它描述了高斯体在各个方向上的分布范围和相关性。**它直接控制了高斯椭球体的形状和朝向**。

为了便于优化，直接优化一个 <img src="https://latex.codecogs.com/svg.latex?3%20%5Ctimes%203" alt="3 \times 3" /> 的协方差矩阵是不稳定且不直观的。因此，论文作者将其分解为两个更易于处理的组件：

* 一个**旋转四元数 (Rotation Quaternion) <img src="https://latex.codecogs.com/svg.latex?q" alt="q" />**，代表椭球体的朝向。
* 一个**三维缩放向量 (Scaling Vector) <img src="https://latex.codecogs.com/svg.latex?s" alt="s" />**，代表椭球体沿其三个主轴的尺寸。

通过四元数 <img src="https://latex.codecogs.com/svg.latex?q" alt="q" /> 可以构建一个旋转矩阵 <img src="https://latex.codecogs.com/svg.latex?R" alt="R" />，通过缩放向量 <img src="https://latex.codecogs.com/svg.latex?s" alt="s" /> 可以构建一个对角缩放矩阵 <img src="https://latex.codecogs.com/svg.latex?S" alt="S" />：

<p align="center">
<img src="https://latex.codecogs.com/svg.latex?S%20%3D%20%5Cbegin%7Bpmatrix%7D%20s_x%20%26%200%20%26%200%20%5C%5C%200%20%26%20s_y%20%26%200%20%5C%5C%200%20%26%200%20%26%20s_z%20%5Cend%7Bpmatrix%7D" alt="S = \begin{pmatrix} s_x & 0 & 0 \\ 0 & s_y & 0 \\ 0 & 0 & s_z \end{pmatrix}" />
</p>

然后，协方差矩阵 <img src="https://latex.codecogs.com/svg.latex?\Sigma" alt="\Sigma" /> 可以通过以下公式重构：

<p align="center">
<img src="https://latex.codecogs.com/svg.latex?%5CSigma%20%3D%20R%20S%20S%5ET%20R%5ET" alt="\Sigma = R S S^T R^T" />
</p>

这里 <img src="https://latex.codecogs.com/svg.latex?S%20S%5ET" alt="S S^T" /> 是一个对角矩阵，其对角线元素是 <img src="https://latex.codecogs.com/svg.latex?(s_x%5E2%2C%20s_y%5E2%2C%20s_z%5E2)" alt="(s_x^2, s_y^2, s_z^2)" />。这种分解方式将一个复杂的矩阵优化问题，转化为了对旋转（4个值）和缩放（3个值）的优化，更加稳定和高效。

除了形状和位置，每个高斯体还携带另外两个光学属性：

* **颜色 (Color) <img src="https://latex.codecogs.com/svg.latex?c" alt="c" />**: 为了实现视角依赖效果（view-dependent effects），颜色不是一个简单的RGB值，而是用**球谐函数**（Spherical Harmonics, SH）的系数来表示。0阶SH系数代表了该点的基础颜色（diffuse color），而更高阶的系数则可以捕捉到随视角方向变化的颜色分量（specular reflections）。
* **不透明度 (Opacity) <img src="https://latex.codecogs.com/svg.latex?%5Calpha" alt="\alpha" />**: 一个标量，取值范围为 <img src="https://latex.codecogs.com/svg.latex?%5B0%2C%201%5D" alt="[0, 1]" />。它与高斯函数的幅度（amplitude）相结合，共同决定了该高斯体对最终像素颜色的贡献权重。

#### 2. 从3D到2D：可微分的高斯投影

渲染时，我们需要将这些3D高斯体投影到2D的图像平面上。这个过程必须是可微分的，以便梯度能够从像素颜色传回3D高斯体的参数。

给定一个世界坐标到相机坐标的变换矩阵 <img src="https://latex.codecogs.com/svg.latex?W" alt="W" />（Viewing Transformation Matrix）和相机内参的投影变换，一个3D点 <img src="https://latex.codecogs.com/svg.latex?%5Cmu" alt="\mu" /> 被投影到2D屏幕上的点 <img src="https://latex.codecogs.com/svg.latex?%5Cmu%27" alt="\mu'" />。关键在于，我们还需要知道3D协方差矩阵 <img src="https://latex.codecogs.com/svg.latex?%5CSigma" alt="\Sigma" /> 在2D屏幕上对应的2D协方差矩阵 <img src="https://latex.codecogs.com/svg.latex?%5CSigma_%7B2D%7D" alt="\Sigma_{2D}" /> 是什么。

根据链式法则，投影后的2D协方差矩阵 <img src="https://latex.codecogs.com/svg.latex?%5CSigma_%7B2D%7D" alt="\Sigma_{2D}" /> 可以通过以下公式近似计算：

<p align="center">
<img src="https://latex.codecogs.com/svg.latex?%5CSigma_%7B2D%7D%20%3D%20J%20W%20%5CSigma%20W%5ET%20J%5ET" alt="\Sigma_{2D} = J W \Sigma W^T J^T" />
</p>

这里的变量是：

* <img src="https://latex.codecogs.com/svg.latex?W" alt="W" />: <img src="https://latex.codecogs.com/svg.latex?4%20%5Ctimes%204" alt="4 \times 4" /> 的世界坐标到相机坐标的变换矩阵。
* <img src="https://latex.codecogs.com/svg.latex?J" alt="J" />: <img src="https://latex.codecogs.com/svg.latex?2%20%5Ctimes%204" alt="2 \times 4" /> 的**仿射近似投影变换的雅可比矩阵 (Jacobian of the affine approximation of the projective transformation)**。它描述了当3D点在相机空间中发生微小变化时，其2D投影点会如何变化。这个矩阵是局部线性的，它将3D空间的变换映射到2D投影平面的变换。

这个公式是整个可微分渲染管线的核心之一。它精确地计算出3D椭球体投影到2D屏幕上所形成的椭圆的形状和方向，保证了渲染的几何准确性，并且由于<img src="https://latex.codecogs.com/svg.latex?J" alt="J" />和<img src="https://latex.codecogs.com/svg.latex?W" alt="W" />都是已知的线性变换，梯度可以轻松地通过这个公式进行反向传播。

#### 3. 渲染与混合：Alpha Blending 公式

当大量的2D高斯椭圆被“溅射”（Splat）到屏幕上后，我们需要计算每个像素的最终颜色。这通过一个经典的前后顺序（front-to-back）的**Alpha Blending**算法来完成。

首先，需要将所有覆盖某个像素的2D高斯体根据它们的深度（离相机的距离）进行排序，从最远的排到最近的。然后，对于该像素，我们从远到近依次遍历这个列表，累积颜色 <img src="https://latex.codecogs.com/svg.latex?C" alt="C" /> 和不透明度 <img src="https://latex.codecogs.com/svg.latex?A" alt="A" />。

假设我们已经处理了前 <img src="https://latex.codecogs.com/svg.latex?i-1" alt="i-1" /> 个高斯体，得到了累积颜色 <img src="https://latex.codecogs.com/svg.latex?C_%7Bi-1%7D" alt="C_{i-1}" /> 和累积不透明度 <img src="https://latex.codecogs.com/svg.latex?A_%7Bi-1%7D" alt="A_{i-1}" />。现在我们来混合第 <img src="https://latex.codecogs.com/svg.latex?i" alt="i" /> 个高斯体。

第 <img src="https://latex.codecogs.com/svg.latex?i" alt="i" /> 个高斯体的颜色为 <img src="https://latex.codecogs.com/svg.latex?c_i" alt="c_i" />，其在该像素中心点的不透明度贡献为 <img src="https://latex.codecogs.com/svg.latex?%5Calpha%27_i" alt="\alpha'_i" />。这个 <img src="https://latex.codecogs.com/svg.latex?%5Calpha%27_i" alt="\alpha'_i" /> 是通过将该高斯体的不透明度参数 <img src="https://latex.codecogs.com/svg.latex?%5Calpha_i" alt="\alpha_i" /> 乘以其2D高斯函数在该像素中心的值得到的：

<p align="center">
<img src="https://latex.codecogs.com/svg.latex?%5Calpha%27_i%20%3D%20%5Calpha_i%20%5Ccdot%20e%5E%7B-%5Cfrac%7B1%7D%7B2%7D(x_%7Bpix%7D-%5Cmu%27_%7Bi%7D)%5ET%20%5CSigma_%7B2D%2C%20i%7D%5E%7B-1%7D%20(x_%7Bpix%7D-%5Cmu%27_%7Bi%7D)%7D" alt="\alpha'_i = \alpha_i \cdot e^{-\frac{1}{2}(x_{pix}-\mu'_{i})^T \Sigma_{2D, i}^{-1} (x_{pix}-\mu'_{i})}" />
</p>

其中 <img src="https://latex.codecogs.com/svg.latex?x_%7Bpix%7D" alt="x_{pix}" /> 是像素中心的2D坐标，<img src="https://latex.codecogs.com/svg.latex?%5Cmu%27_%7Bi%7D" alt="\mu'_{i}" /> 和 <img src="https://latex.codecogs.com/svg.latex?%5CSigma_%7B2D%2C%20i%7D" alt="\Sigma_{2D, i}" /> 分别是第 <img src="https://latex.codecogs.com/svg.latex?i" alt="i" /> 个高斯体投影后的2D中心和2D协方差矩阵。

然后，新的累积颜色 <img src="https://latex.codecogs.com/svg.latex?C_i" alt="C_i" /> 和累积不透明度 <img src="https://latex.codecogs.com/svg.latex?A_i" alt="A_i" /> 通过以下公式更新：

<p align="center">
<img src="https://latex.codecogs.com/svg.latex?C_i%20%3D%20C_%7Bi-1%7D%20%2B%20(1%20-%20A_%7Bi-1%7D)%20%5Calpha%27_i%20c_i" alt="C_i = C_{i-1} + (1 - A_{i-1}) \alpha'_i c_i" />
</p>

<p align="center">
<img src="https://latex.codecogs.com/svg.latex?A_i%20%3D%20A_%7Bi-1%7D%20%2B%20(1%20-%20A_%7Bi-1%7D)%20%5Calpha%27_i" alt="A_i = A_{i-1} + (1 - A_{i-1}) \alpha'_i" />
</p>

这个公式的直观解释是：
* 新的颜色 <img src="https://latex.codecogs.com/svg.latex?C_i" alt="C_i" /> 是由旧的颜色 <img src="https://latex.codecogs.com/svg.latex?C_%7Bi-1%7D" alt="C_{i-1}" /> 加上当前第 <img src="https://latex.codecogs.com/svg.latex?i" alt="i" /> 个高斯体的颜色 <img src="https://latex.codecogs.com/svg.latex?c_i" alt="c_i" /> 组成的。
* 但是，<img src="https://latex.codecogs.com/svg.latex?c_i" alt="c_i" /> 的贡献需要被它自身的不透明度 <img src="https://latex.codecogs.com/svg.latex?%5Calpha%27_i" alt="\alpha'_i" /> 和**它前面所有物体累积起来的“剩余光线通过率”** <img src="https://latex.codecogs.com/svg.latex?(1%20-%20A_%7Bi-1%7D)" alt="(1 - A_{i-1})" /> 所调制。如果前面的物体已经完全不透明了（<img src="https://latex.codecogs.com/svg.latex?A_%7Bi-1%7D%3D1" alt="A_{i-1}=1" />），那么当前物体就对最终颜色没有任何贡献了。

这个过程从远到近对所有 <img src="https://latex.codecogs.com/svg.latex?N" alt="N" /> 个高斯体迭代进行，最终得到的 <img src="https://latex.codecogs.com/svg.latex?C_N" alt="C_N" /> 就是该像素的最终颜色。因为每一步都是简单的乘法和加法，所以整个混合过程同样是完全可微分的。

#### 4. 优化：损失函数的数学表达

优化的目标是让渲染出的图像与真实图像尽可能接近。损失函数 <img src="https://latex.codecogs.com/svg.latex?L" alt="L" /> 通常由两部分组成：

<p align="center">
<img src="https://latex.codecogs.com/svg.latex?L%20%3D%20(1%20-%20%5Clambda)%20%5Cmathcal%7BL%7D_%7B%5Ctext%7BL1%7D%7D%20%2B%20%5Clambda%20%5Cmathcal%7BL%7D_%7B%5Ctext%7BD-SSIM%7D%7D" alt="L = (1 - \lambda) \mathcal{L}_{\text{L1}} + \lambda \mathcal{L}_{\text{D-SSIM}}" />
</p>

* <img src="https://latex.codecogs.com/svg.latex?%5Cmathcal%7BL%7D_%7B%5Ctext%7BL1%7D%7D" alt="\mathcal{L}_{\text{L1}}" />: **L1损失**，也叫作平均绝对误差。它计算渲染图像 <img src="https://latex.codecogs.com/svg.latex?%5Chat%7BI%7D" alt="\hat{I}" /> 和真实图像 <img src="https://latex.codecogs.com/svg.latex?I" alt="I" /> 之间每个像素颜色值的绝对差之和。它能保证整体颜色的准确性。
    
    <p align="center">
    <img src="https://latex.codecogs.com/svg.latex?%5Cmathcal%7BL%7D_%7B%5Ctext%7BL1%7D%7D%20%3D%20%5Csum_%7Bp%20%5Cin%20%5Ctext%7Bpixels%7D%7D%20%7C%5Chat%7BI%7D(p)%20-%20I(p)%7C" alt="\mathcal{L}_{\text{L1}} = \sum_{p \in \text{pixels}} |\hat{I}(p) - I(p)|" />
    </p>
    
* <img src="https://latex.codecogs.com/svg.latex?%5Cmathcal%7BL%7D_%7B%5Ctext%7BD-SSIM%7D%7D" alt="\mathcal{L}_{\text{D-SSIM}}" />: **结构相似性（SSIM）**损失。SSIM是一种衡量两张图片结构相似度的指标，它对亮度、对比度和结构进行综合评估，比L1更能保留图像的高频细节和纹理。D-SSIM (Structural Dissimilarity) 通常定义为 <img src="https://latex.codecogs.com/svg.latex?1%20-%20%5Ctext%7BSSIM%7D" alt="1 - \text{SSIM}" />。
    
    <p align="center">
    <img src="https://latex.codecogs.com/svg.latex?%5Cmathcal%7BL%7D_%7B%5Ctext%7BD-SSIM%7D%7D%20%3D%201%20-%20%5Ctext%7BSSIM%7D(%5Chat%7BI%7D%2C%20I)" alt="\mathcal{L}_{\text{D-SSIM}} = 1 - \text{SSIM}(\hat{I}, I)" />
    </p>

通过随机梯度下降（SGD）算法，系统计算损失函数 <img src="https://latex.codecogs.com/svg.latex?L" alt="L" /> 相对于所有高斯体参数（<img src="https://latex.codecogs.com/svg.latex?%5Cmu%2C%20q%2C%20s%2C%20c%2C%20%5Calpha" alt="\mu, q, s, c, \alpha" />）的梯度 <img src="https://latex.codecogs.com/svg.latex?%5Cnabla%20L" alt="\nabla L" />，并沿着梯度的反方向更新这些参数，从而使渲染结果不断逼近真实场景。<img src="https://latex.codecogs.com/svg.latex?%5Clambda" alt="\lambda" /> 是一个超参数，通常设为0.2，用于平衡两种损失的权重。
